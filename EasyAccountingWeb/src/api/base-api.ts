//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.1.0 (NJsonSchema v11.5.1.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IActionService {
    create(createActionCommand: CreateActionCommand): Observable<boolean>;
    delete(id: string): Observable<boolean>;
    getById(id: string): Observable<ActionViewModel>;
    getFilterActions(getActionsByFilterQuery: GetActionsByFilterQuery): Observable<FilterPageResultModelOfActionGridModel>;
    update(updateActionCommand: UpdateActionCommand): Observable<boolean>;
}

@Injectable()
export class ActionService implements IActionService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    create(createActionCommand: CreateActionCommand): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Action/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createActionCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Action/Delete/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(id: string): Observable<ActionViewModel> {
        let url_ = this.baseUrl + "/api/Action/GetById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActionViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActionViewModel>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ActionViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActionViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getFilterActions(getActionsByFilterQuery: GetActionsByFilterQuery): Observable<FilterPageResultModelOfActionGridModel> {
        let url_ = this.baseUrl + "/api/Action/GetFilterActions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(getActionsByFilterQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFilterActions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFilterActions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilterPageResultModelOfActionGridModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilterPageResultModelOfActionGridModel>;
        }));
    }

    protected processGetFilterActions(response: HttpResponseBase): Observable<FilterPageResultModelOfActionGridModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilterPageResultModelOfActionGridModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(updateActionCommand: UpdateActionCommand): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Action/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateActionCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IAuthenticationService {
    login(command: LoginCommand): Observable<AuthenticationViewModel>;
    registration(command: RegistrationCommand): Observable<UserModel>;
}

@Injectable()
export class AuthenticationService implements IAuthenticationService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    login(command: LoginCommand): Observable<AuthenticationViewModel> {
        let url_ = this.baseUrl + "/api/Authentication/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticationViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticationViewModel>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<AuthenticationViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticationViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    registration(command: RegistrationCommand): Observable<UserModel> {
        let url_ = this.baseUrl + "/api/Authentication/Registration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserModel>;
        }));
    }

    protected processRegistration(response: HttpResponseBase): Observable<UserModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }
}

export interface ICityService {
    create(createCityCommand: CreateCityCommand): Observable<boolean>;
    delete(id: string): Observable<boolean>;
    getById(id: string): Observable<CityViewModel>;
    getCityByCountryId(countryId: number): Observable<SelectModel[]>;
    getFilterCities(getCitiesByFilterQuery: GetCityByFilterQuery): Observable<FilterPageResultModelOfCityGridModel>;
    update(updateCityCommand: UpdateCityCommand): Observable<boolean>;
}

@Injectable()
export class CityService implements ICityService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    create(createCityCommand: CreateCityCommand): Observable<boolean> {
        let url_ = this.baseUrl + "/api/City/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createCityCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/City/Delete/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(id: string): Observable<CityViewModel> {
        let url_ = this.baseUrl + "/api/City/GetById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CityViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CityViewModel>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<CityViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CityViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCityByCountryId(countryId: number): Observable<SelectModel[]> {
        let url_ = this.baseUrl + "/api/City/GetCityByCountryId/{countryId}";
        if (countryId === undefined || countryId === null)
            throw new globalThis.Error("The parameter 'countryId' must be defined.");
        url_ = url_.replace("{countryId}", encodeURIComponent("" + countryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCityByCountryId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCityByCountryId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectModel[]>;
        }));
    }

    protected processGetCityByCountryId(response: HttpResponseBase): Observable<SelectModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SelectModel.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getFilterCities(getCitiesByFilterQuery: GetCityByFilterQuery): Observable<FilterPageResultModelOfCityGridModel> {
        let url_ = this.baseUrl + "/api/City/GetFilterCities";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(getCitiesByFilterQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFilterCities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFilterCities(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilterPageResultModelOfCityGridModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilterPageResultModelOfCityGridModel>;
        }));
    }

    protected processGetFilterCities(response: HttpResponseBase): Observable<FilterPageResultModelOfCityGridModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilterPageResultModelOfCityGridModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(updateCityCommand: UpdateCityCommand): Observable<boolean> {
        let url_ = this.baseUrl + "/api/City/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateCityCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICompanyService {
    create(createCompanyCommand: CompanyCreateCommand): Observable<boolean>;
    delete(id: string): Observable<boolean>;
    getById(id: string): Observable<CompanyViewModel>;
    getFilterCompanies(getCompaniesByFilterQuery: GetCompaniesByFilterQuery): Observable<FilterPageResultModelOfCompanyGridModel>;
    update(updateCompanyCommand: CompanyUpdateCommand): Observable<boolean>;
}

@Injectable()
export class CompanyService implements ICompanyService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    create(createCompanyCommand: CompanyCreateCommand): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Company/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createCompanyCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Company/Delete/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(id: string): Observable<CompanyViewModel> {
        let url_ = this.baseUrl + "/api/Company/GetById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyViewModel>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<CompanyViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getFilterCompanies(getCompaniesByFilterQuery: GetCompaniesByFilterQuery): Observable<FilterPageResultModelOfCompanyGridModel> {
        let url_ = this.baseUrl + "/api/Company/GetFilterCompanies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(getCompaniesByFilterQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFilterCompanies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFilterCompanies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilterPageResultModelOfCompanyGridModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilterPageResultModelOfCompanyGridModel>;
        }));
    }

    protected processGetFilterCompanies(response: HttpResponseBase): Observable<FilterPageResultModelOfCompanyGridModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilterPageResultModelOfCompanyGridModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(updateCompanyCommand: CompanyUpdateCommand): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Company/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateCompanyCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICountryService {
    create(createCountryCommand: CreateCountryCommand): Observable<boolean>;
    delete(id: string): Observable<boolean>;
    getAll(): Observable<CountryGridModel[]>;
    getById(id: string): Observable<CountryViewModel>;
    getFilterCountries(getCountriesByFilterQuery: GetCountriesByFilterQuery): Observable<FilterPageResultModelOfCountryGridModel>;
    update(updateCountryCommand: UpdateCountryCommand): Observable<boolean>;
}

@Injectable()
export class CountryService implements ICountryService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    create(createCountryCommand: CreateCountryCommand): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Country/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createCountryCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Country/Delete/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAll(): Observable<CountryGridModel[]> {
        let url_ = this.baseUrl + "/api/Country/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryGridModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryGridModel[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CountryGridModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CountryGridModel.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(id: string): Observable<CountryViewModel> {
        let url_ = this.baseUrl + "/api/Country/GetById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryViewModel>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<CountryViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getFilterCountries(getCountriesByFilterQuery: GetCountriesByFilterQuery): Observable<FilterPageResultModelOfCountryGridModel> {
        let url_ = this.baseUrl + "/api/Country/GetFilterCountries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(getCountriesByFilterQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFilterCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFilterCountries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilterPageResultModelOfCountryGridModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilterPageResultModelOfCountryGridModel>;
        }));
    }

    protected processGetFilterCountries(response: HttpResponseBase): Observable<FilterPageResultModelOfCountryGridModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilterPageResultModelOfCountryGridModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(updateCountryCommand: UpdateCountryCommand): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Country/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateCountryCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICurrencyService {
    create(createCurrencyCommand: CreateCurrencyCommand): Observable<boolean>;
    delete(id: string): Observable<boolean>;
    getById(id: string): Observable<CurrencyViewModel>;
    getFilterCurrencies(getCurrenciesByFilterQuery: GetCurrenciesByFilterQuery): Observable<FilterPageResultModelOfCurrencyGridModel>;
    update(updateCurrencyCommand: UpdateCurrencyCommand): Observable<boolean>;
}

@Injectable()
export class CurrencyService implements ICurrencyService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    create(createCurrencyCommand: CreateCurrencyCommand): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Currency/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createCurrencyCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Currency/Delete/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(id: string): Observable<CurrencyViewModel> {
        let url_ = this.baseUrl + "/api/Currency/GetById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrencyViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrencyViewModel>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<CurrencyViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrencyViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getFilterCurrencies(getCurrenciesByFilterQuery: GetCurrenciesByFilterQuery): Observable<FilterPageResultModelOfCurrencyGridModel> {
        let url_ = this.baseUrl + "/api/Currency/GetFilterCurrencies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(getCurrenciesByFilterQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFilterCurrencies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFilterCurrencies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilterPageResultModelOfCurrencyGridModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilterPageResultModelOfCurrencyGridModel>;
        }));
    }

    protected processGetFilterCurrencies(response: HttpResponseBase): Observable<FilterPageResultModelOfCurrencyGridModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilterPageResultModelOfCurrencyGridModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(updateCurrencyCommand: UpdateCurrencyCommand): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Currency/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateCurrencyCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IInvoiceSettingService {
    create(createInvoiveSettingCommand: CreateInvoiceSettingCommand): Observable<boolean>;
    delete(id: string): Observable<boolean>;
    getById(id: string): Observable<InvoiceSettingViewModel>;
    getFilterInvoiceSettings(getinvoiceSettingsByFilterQuery: GetInvoiceSettingsByFilterQuery): Observable<FilterPageResultModelOfInvoiceSettingGridModel>;
    update(updateInvoiceSettingCommand: UpdateInvoiceSettingCommand): Observable<boolean>;
}

@Injectable()
export class InvoiceSettingService implements IInvoiceSettingService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    create(createInvoiveSettingCommand: CreateInvoiceSettingCommand): Observable<boolean> {
        let url_ = this.baseUrl + "/api/InvoiceSetting/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createInvoiveSettingCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/InvoiceSetting/Delete/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(id: string): Observable<InvoiceSettingViewModel> {
        let url_ = this.baseUrl + "/api/InvoiceSetting/GetById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceSettingViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceSettingViewModel>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<InvoiceSettingViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceSettingViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getFilterInvoiceSettings(getinvoiceSettingsByFilterQuery: GetInvoiceSettingsByFilterQuery): Observable<FilterPageResultModelOfInvoiceSettingGridModel> {
        let url_ = this.baseUrl + "/api/InvoiceSetting/GetFilterInvoiceSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(getinvoiceSettingsByFilterQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFilterInvoiceSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFilterInvoiceSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilterPageResultModelOfInvoiceSettingGridModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilterPageResultModelOfInvoiceSettingGridModel>;
        }));
    }

    protected processGetFilterInvoiceSettings(response: HttpResponseBase): Observable<FilterPageResultModelOfInvoiceSettingGridModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilterPageResultModelOfInvoiceSettingGridModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(updateInvoiceSettingCommand: UpdateInvoiceSettingCommand): Observable<boolean> {
        let url_ = this.baseUrl + "/api/InvoiceSetting/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateInvoiceSettingCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IModuleService {
    create(createModuleCommand: CreateModuleCommand): Observable<boolean>;
    delete(id: string): Observable<boolean>;
    getById(id: string): Observable<ModuleViewModel>;
    getFilterModules(getModulesByFilterQuery: GetModulesByFilterQuery): Observable<FilterPageResultModelOfModuleGridModel>;
    update(updateModuleCommand: UpdateModuleCommand): Observable<boolean>;
}

@Injectable()
export class ModuleService implements IModuleService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    create(createModuleCommand: CreateModuleCommand): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Module/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createModuleCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Module/Delete/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(id: string): Observable<ModuleViewModel> {
        let url_ = this.baseUrl + "/api/Module/GetById/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ModuleViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ModuleViewModel>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ModuleViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ModuleViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getFilterModules(getModulesByFilterQuery: GetModulesByFilterQuery): Observable<FilterPageResultModelOfModuleGridModel> {
        let url_ = this.baseUrl + "/api/Module/GetFilterModules";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(getModulesByFilterQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFilterModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFilterModules(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FilterPageResultModelOfModuleGridModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FilterPageResultModelOfModuleGridModel>;
        }));
    }

    protected processGetFilterModules(response: HttpResponseBase): Observable<FilterPageResultModelOfModuleGridModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilterPageResultModelOfModuleGridModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(updateModuleCommand: UpdateModuleCommand): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Module/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateModuleCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class FilterPageResultModelOfCompanyGridModel implements IFilterPageResultModelOfCompanyGridModel {
    items?: CompanyGridModel[];
    totalCount?: number;

    constructor(data?: IFilterPageResultModelOfCompanyGridModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CompanyGridModel.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): FilterPageResultModelOfCompanyGridModel {
        data = typeof data === 'object' ? data : {};
        let result = new FilterPageResultModelOfCompanyGridModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IFilterPageResultModelOfCompanyGridModel {
    items?: CompanyGridModel[];
    totalCount?: number;
}

export class CompanyGridModel implements ICompanyGridModel {
    id?: string;
    name?: string;
    email?: string | undefined;
    phone?: string;
    countryName?: string;
    cityName?: string;
    currencyName?: string;
    logo?: string | undefined;
    taxNo?: string | undefined;
    isSellWithPos?: boolean;
    isProductHaveBrand?: boolean;
    isDefaultCompany?: boolean;
    address?: string | undefined;

    constructor(data?: ICompanyGridModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.countryName = _data["countryName"];
            this.cityName = _data["cityName"];
            this.currencyName = _data["currencyName"];
            this.logo = _data["logo"];
            this.taxNo = _data["taxNo"];
            this.isSellWithPos = _data["isSellWithPos"];
            this.isProductHaveBrand = _data["isProductHaveBrand"];
            this.isDefaultCompany = _data["isDefaultCompany"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): CompanyGridModel {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyGridModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["countryName"] = this.countryName;
        data["cityName"] = this.cityName;
        data["currencyName"] = this.currencyName;
        data["logo"] = this.logo;
        data["taxNo"] = this.taxNo;
        data["isSellWithPos"] = this.isSellWithPos;
        data["isProductHaveBrand"] = this.isProductHaveBrand;
        data["isDefaultCompany"] = this.isDefaultCompany;
        data["address"] = this.address;
        return data;
    }
}

export interface ICompanyGridModel {
    id?: string;
    name?: string;
    email?: string | undefined;
    phone?: string;
    countryName?: string;
    cityName?: string;
    currencyName?: string;
    logo?: string | undefined;
    taxNo?: string | undefined;
    isSellWithPos?: boolean;
    isProductHaveBrand?: boolean;
    isDefaultCompany?: boolean;
    address?: string | undefined;
}

export class FilterPageModel implements IFilterPageModel {
    pageIndex?: number;
    pageSize?: number;
    sortColumn?: string | undefined;
    sortOrder?: string | undefined;
    filterValue?: string | undefined;

    constructor(data?: IFilterPageModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            this.sortColumn = _data["sortColumn"];
            this.sortOrder = _data["sortOrder"];
            this.filterValue = _data["filterValue"];
        }
    }

    static fromJS(data: any): FilterPageModel {
        data = typeof data === 'object' ? data : {};
        let result = new FilterPageModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["sortColumn"] = this.sortColumn;
        data["sortOrder"] = this.sortOrder;
        data["filterValue"] = this.filterValue;
        return data;
    }
}

export interface IFilterPageModel {
    pageIndex?: number;
    pageSize?: number;
    sortColumn?: string | undefined;
    sortOrder?: string | undefined;
    filterValue?: string | undefined;
}

export class GetCompaniesByFilterQuery extends FilterPageModel implements IGetCompaniesByFilterQuery {

    constructor(data?: IGetCompaniesByFilterQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): GetCompaniesByFilterQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetCompaniesByFilterQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IGetCompaniesByFilterQuery extends IFilterPageModel {
}

export class CompanyViewModel implements ICompanyViewModel {
    createModel?: CompanyCreateModel;
    updateModel?: CompanyUpdateModel;
    gridModel?: CompanyGridModel;
    optionsDataSources?: any;

    constructor(data?: ICompanyViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createModel = _data["createModel"] ? CompanyCreateModel.fromJS(_data["createModel"]) : undefined as any;
            this.updateModel = _data["updateModel"] ? CompanyUpdateModel.fromJS(_data["updateModel"]) : undefined as any;
            this.gridModel = _data["gridModel"] ? CompanyGridModel.fromJS(_data["gridModel"]) : undefined as any;
            this.optionsDataSources = _data["optionsDataSources"];
        }
    }

    static fromJS(data: any): CompanyViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createModel"] = this.createModel ? this.createModel.toJSON() : undefined as any;
        data["updateModel"] = this.updateModel ? this.updateModel.toJSON() : undefined as any;
        data["gridModel"] = this.gridModel ? this.gridModel.toJSON() : undefined as any;
        data["optionsDataSources"] = this.optionsDataSources;
        return data;
    }
}

export interface ICompanyViewModel {
    createModel?: CompanyCreateModel;
    updateModel?: CompanyUpdateModel;
    gridModel?: CompanyGridModel;
    optionsDataSources?: any;
}

export class CompanyCreateModel implements ICompanyCreateModel {
    name!: string;
    email?: string | undefined;
    phone!: string;
    countryId!: number;
    cityId!: number;
    currencyId!: number;
    logo?: string | undefined;
    taxNo?: string | undefined;
    isSellWithPos?: boolean;
    isProductHaveBrand?: boolean;
    isDefaultCompany?: boolean;
    address?: string | undefined;

    constructor(data?: ICompanyCreateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.countryId = _data["countryId"];
            this.cityId = _data["cityId"];
            this.currencyId = _data["currencyId"];
            this.logo = _data["logo"];
            this.taxNo = _data["taxNo"];
            this.isSellWithPos = _data["isSellWithPos"];
            this.isProductHaveBrand = _data["isProductHaveBrand"];
            this.isDefaultCompany = _data["isDefaultCompany"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): CompanyCreateModel {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyCreateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["countryId"] = this.countryId;
        data["cityId"] = this.cityId;
        data["currencyId"] = this.currencyId;
        data["logo"] = this.logo;
        data["taxNo"] = this.taxNo;
        data["isSellWithPos"] = this.isSellWithPos;
        data["isProductHaveBrand"] = this.isProductHaveBrand;
        data["isDefaultCompany"] = this.isDefaultCompany;
        data["address"] = this.address;
        return data;
    }
}

export interface ICompanyCreateModel {
    name: string;
    email?: string | undefined;
    phone: string;
    countryId: number;
    cityId: number;
    currencyId: number;
    logo?: string | undefined;
    taxNo?: string | undefined;
    isSellWithPos?: boolean;
    isProductHaveBrand?: boolean;
    isDefaultCompany?: boolean;
    address?: string | undefined;
}

export class CompanyUpdateModel implements ICompanyUpdateModel {
    id?: number;
    name!: string;
    email?: string | undefined;
    phone!: string;
    countryId!: number;
    cityId!: number;
    currencyId!: number;
    logo?: string | undefined;
    taxNo?: string | undefined;
    isSellWithPos?: boolean;
    isProductHaveBrand?: boolean;
    isDefaultCompany?: boolean;
    address?: string | undefined;

    constructor(data?: ICompanyUpdateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.countryId = _data["countryId"];
            this.cityId = _data["cityId"];
            this.currencyId = _data["currencyId"];
            this.logo = _data["logo"];
            this.taxNo = _data["taxNo"];
            this.isSellWithPos = _data["isSellWithPos"];
            this.isProductHaveBrand = _data["isProductHaveBrand"];
            this.isDefaultCompany = _data["isDefaultCompany"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): CompanyUpdateModel {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyUpdateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["countryId"] = this.countryId;
        data["cityId"] = this.cityId;
        data["currencyId"] = this.currencyId;
        data["logo"] = this.logo;
        data["taxNo"] = this.taxNo;
        data["isSellWithPos"] = this.isSellWithPos;
        data["isProductHaveBrand"] = this.isProductHaveBrand;
        data["isDefaultCompany"] = this.isDefaultCompany;
        data["address"] = this.address;
        return data;
    }
}

export interface ICompanyUpdateModel {
    id?: number;
    name: string;
    email?: string | undefined;
    phone: string;
    countryId: number;
    cityId: number;
    currencyId: number;
    logo?: string | undefined;
    taxNo?: string | undefined;
    isSellWithPos?: boolean;
    isProductHaveBrand?: boolean;
    isDefaultCompany?: boolean;
    address?: string | undefined;
}

export class CompanyCreateCommand extends CompanyCreateModel implements ICompanyCreateCommand {

    constructor(data?: ICompanyCreateCommand) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): CompanyCreateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyCreateCommand();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICompanyCreateCommand extends ICompanyCreateModel {
}

export class CompanyUpdateCommand extends CompanyUpdateModel implements ICompanyUpdateCommand {

    constructor(data?: ICompanyUpdateCommand) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): CompanyUpdateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyUpdateCommand();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICompanyUpdateCommand extends ICompanyUpdateModel {
}

export class FilterPageResultModelOfCurrencyGridModel implements IFilterPageResultModelOfCurrencyGridModel {
    items?: CurrencyGridModel[];
    totalCount?: number;

    constructor(data?: IFilterPageResultModelOfCurrencyGridModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CurrencyGridModel.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): FilterPageResultModelOfCurrencyGridModel {
        data = typeof data === 'object' ? data : {};
        let result = new FilterPageResultModelOfCurrencyGridModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IFilterPageResultModelOfCurrencyGridModel {
    items?: CurrencyGridModel[];
    totalCount?: number;
}

export class CurrencyGridModel implements ICurrencyGridModel {
    id?: string;
    name?: string;
    baseRate?: number;
    symble?: string | undefined;

    constructor(data?: ICurrencyGridModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.baseRate = _data["baseRate"];
            this.symble = _data["symble"];
        }
    }

    static fromJS(data: any): CurrencyGridModel {
        data = typeof data === 'object' ? data : {};
        let result = new CurrencyGridModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["baseRate"] = this.baseRate;
        data["symble"] = this.symble;
        return data;
    }
}

export interface ICurrencyGridModel {
    id?: string;
    name?: string;
    baseRate?: number;
    symble?: string | undefined;
}

export class GetCurrenciesByFilterQuery extends FilterPageModel implements IGetCurrenciesByFilterQuery {

    constructor(data?: IGetCurrenciesByFilterQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): GetCurrenciesByFilterQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrenciesByFilterQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IGetCurrenciesByFilterQuery extends IFilterPageModel {
}

export class CurrencyViewModel implements ICurrencyViewModel {
    createModel?: CurrencyCreateModel;
    updateModel?: CurrencyUpdateModel;
    gridModel?: CurrencyGridModel;

    constructor(data?: ICurrencyViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createModel = _data["createModel"] ? CurrencyCreateModel.fromJS(_data["createModel"]) : undefined as any;
            this.updateModel = _data["updateModel"] ? CurrencyUpdateModel.fromJS(_data["updateModel"]) : undefined as any;
            this.gridModel = _data["gridModel"] ? CurrencyGridModel.fromJS(_data["gridModel"]) : undefined as any;
        }
    }

    static fromJS(data: any): CurrencyViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new CurrencyViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createModel"] = this.createModel ? this.createModel.toJSON() : undefined as any;
        data["updateModel"] = this.updateModel ? this.updateModel.toJSON() : undefined as any;
        data["gridModel"] = this.gridModel ? this.gridModel.toJSON() : undefined as any;
        return data;
    }
}

export interface ICurrencyViewModel {
    createModel?: CurrencyCreateModel;
    updateModel?: CurrencyUpdateModel;
    gridModel?: CurrencyGridModel;
}

export class CurrencyCreateModel implements ICurrencyCreateModel {
    name!: string;
    baseRate!: number;
    symble?: string | undefined;

    constructor(data?: ICurrencyCreateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.baseRate = _data["baseRate"];
            this.symble = _data["symble"];
        }
    }

    static fromJS(data: any): CurrencyCreateModel {
        data = typeof data === 'object' ? data : {};
        let result = new CurrencyCreateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["baseRate"] = this.baseRate;
        data["symble"] = this.symble;
        return data;
    }
}

export interface ICurrencyCreateModel {
    name: string;
    baseRate: number;
    symble?: string | undefined;
}

export class CurrencyUpdateModel implements ICurrencyUpdateModel {
    id?: number;
    name!: string;
    baseRate!: number;
    symble?: string | undefined;

    constructor(data?: ICurrencyUpdateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.baseRate = _data["baseRate"];
            this.symble = _data["symble"];
        }
    }

    static fromJS(data: any): CurrencyUpdateModel {
        data = typeof data === 'object' ? data : {};
        let result = new CurrencyUpdateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["baseRate"] = this.baseRate;
        data["symble"] = this.symble;
        return data;
    }
}

export interface ICurrencyUpdateModel {
    id?: number;
    name: string;
    baseRate: number;
    symble?: string | undefined;
}

export class CreateCurrencyCommand extends CurrencyCreateModel implements ICreateCurrencyCommand {

    constructor(data?: ICreateCurrencyCommand) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): CreateCurrencyCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCurrencyCommand();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICreateCurrencyCommand extends ICurrencyCreateModel {
}

export class UpdateCurrencyCommand extends CurrencyUpdateModel implements IUpdateCurrencyCommand {

    constructor(data?: IUpdateCurrencyCommand) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): UpdateCurrencyCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCurrencyCommand();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateCurrencyCommand extends ICurrencyUpdateModel {
}

export class FilterPageResultModelOfInvoiceSettingGridModel implements IFilterPageResultModelOfInvoiceSettingGridModel {
    items?: InvoiceSettingGridModel[];
    totalCount?: number;

    constructor(data?: IFilterPageResultModelOfInvoiceSettingGridModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(InvoiceSettingGridModel.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): FilterPageResultModelOfInvoiceSettingGridModel {
        data = typeof data === 'object' ? data : {};
        let result = new FilterPageResultModelOfInvoiceSettingGridModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IFilterPageResultModelOfInvoiceSettingGridModel {
    items?: InvoiceSettingGridModel[];
    totalCount?: number;
}

export class InvoiceSettingGridModel implements IInvoiceSettingGridModel {
    id?: number;
    companyName?: string;
    invoiceDueDateCount?: number;
    invoiceColor?: string | undefined;
    invoiceFooter?: string | undefined;
    invoiceTerms?: string | undefined;
    isHideInvoiceHeader?: boolean;
    isShowPreviousDue?: boolean;
    isShowInvoiceCreatorName?: boolean;
    isShowCustomerSignature?: boolean;
    isCreateInvoiceWithoutPurchase?: boolean;
    isServiceProviderAttributionUnderInvoice?: boolean;
    isDefaultInvoiceSetting?: boolean;

    constructor(data?: IInvoiceSettingGridModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyName = _data["companyName"];
            this.invoiceDueDateCount = _data["invoiceDueDateCount"];
            this.invoiceColor = _data["invoiceColor"];
            this.invoiceFooter = _data["invoiceFooter"];
            this.invoiceTerms = _data["invoiceTerms"];
            this.isHideInvoiceHeader = _data["isHideInvoiceHeader"];
            this.isShowPreviousDue = _data["isShowPreviousDue"];
            this.isShowInvoiceCreatorName = _data["isShowInvoiceCreatorName"];
            this.isShowCustomerSignature = _data["isShowCustomerSignature"];
            this.isCreateInvoiceWithoutPurchase = _data["isCreateInvoiceWithoutPurchase"];
            this.isServiceProviderAttributionUnderInvoice = _data["isServiceProviderAttributionUnderInvoice"];
            this.isDefaultInvoiceSetting = _data["isDefaultInvoiceSetting"];
        }
    }

    static fromJS(data: any): InvoiceSettingGridModel {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceSettingGridModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyName"] = this.companyName;
        data["invoiceDueDateCount"] = this.invoiceDueDateCount;
        data["invoiceColor"] = this.invoiceColor;
        data["invoiceFooter"] = this.invoiceFooter;
        data["invoiceTerms"] = this.invoiceTerms;
        data["isHideInvoiceHeader"] = this.isHideInvoiceHeader;
        data["isShowPreviousDue"] = this.isShowPreviousDue;
        data["isShowInvoiceCreatorName"] = this.isShowInvoiceCreatorName;
        data["isShowCustomerSignature"] = this.isShowCustomerSignature;
        data["isCreateInvoiceWithoutPurchase"] = this.isCreateInvoiceWithoutPurchase;
        data["isServiceProviderAttributionUnderInvoice"] = this.isServiceProviderAttributionUnderInvoice;
        data["isDefaultInvoiceSetting"] = this.isDefaultInvoiceSetting;
        return data;
    }
}

export interface IInvoiceSettingGridModel {
    id?: number;
    companyName?: string;
    invoiceDueDateCount?: number;
    invoiceColor?: string | undefined;
    invoiceFooter?: string | undefined;
    invoiceTerms?: string | undefined;
    isHideInvoiceHeader?: boolean;
    isShowPreviousDue?: boolean;
    isShowInvoiceCreatorName?: boolean;
    isShowCustomerSignature?: boolean;
    isCreateInvoiceWithoutPurchase?: boolean;
    isServiceProviderAttributionUnderInvoice?: boolean;
    isDefaultInvoiceSetting?: boolean;
}

export class GetInvoiceSettingsByFilterQuery extends FilterPageModel implements IGetInvoiceSettingsByFilterQuery {

    constructor(data?: IGetInvoiceSettingsByFilterQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): GetInvoiceSettingsByFilterQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetInvoiceSettingsByFilterQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IGetInvoiceSettingsByFilterQuery extends IFilterPageModel {
}

export class InvoiceSettingViewModel implements IInvoiceSettingViewModel {
    createModel?: InvoiceSettingCreateModel;
    updateModel?: InvoiceSettingUpdateModel;
    gridModel?: InvoiceSettingGridModel;
    optionsDataSources?: any;

    constructor(data?: IInvoiceSettingViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createModel = _data["createModel"] ? InvoiceSettingCreateModel.fromJS(_data["createModel"]) : undefined as any;
            this.updateModel = _data["updateModel"] ? InvoiceSettingUpdateModel.fromJS(_data["updateModel"]) : undefined as any;
            this.gridModel = _data["gridModel"] ? InvoiceSettingGridModel.fromJS(_data["gridModel"]) : undefined as any;
            this.optionsDataSources = _data["optionsDataSources"];
        }
    }

    static fromJS(data: any): InvoiceSettingViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceSettingViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createModel"] = this.createModel ? this.createModel.toJSON() : undefined as any;
        data["updateModel"] = this.updateModel ? this.updateModel.toJSON() : undefined as any;
        data["gridModel"] = this.gridModel ? this.gridModel.toJSON() : undefined as any;
        data["optionsDataSources"] = this.optionsDataSources;
        return data;
    }
}

export interface IInvoiceSettingViewModel {
    createModel?: InvoiceSettingCreateModel;
    updateModel?: InvoiceSettingUpdateModel;
    gridModel?: InvoiceSettingGridModel;
    optionsDataSources?: any;
}

export class InvoiceSettingCreateModel implements IInvoiceSettingCreateModel {
    companyId!: number;
    invoiceDueDateCount!: number;
    invoiceColor?: string | undefined;
    invoiceFooter?: string | undefined;
    invoiceTerms?: string | undefined;
    isHideInvoiceHeader?: boolean;
    isShowPreviousDue?: boolean;
    isShowInvoiceCreatorName?: boolean;
    isShowCustomerSignature?: boolean;
    isCreateInvoiceWithoutPurchase?: boolean;
    isServiceProviderAttributionUnderInvoice?: boolean;
    isDefaultInvoiceSetting?: boolean;

    constructor(data?: IInvoiceSettingCreateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyId = _data["companyId"];
            this.invoiceDueDateCount = _data["invoiceDueDateCount"];
            this.invoiceColor = _data["invoiceColor"];
            this.invoiceFooter = _data["invoiceFooter"];
            this.invoiceTerms = _data["invoiceTerms"];
            this.isHideInvoiceHeader = _data["isHideInvoiceHeader"];
            this.isShowPreviousDue = _data["isShowPreviousDue"];
            this.isShowInvoiceCreatorName = _data["isShowInvoiceCreatorName"];
            this.isShowCustomerSignature = _data["isShowCustomerSignature"];
            this.isCreateInvoiceWithoutPurchase = _data["isCreateInvoiceWithoutPurchase"];
            this.isServiceProviderAttributionUnderInvoice = _data["isServiceProviderAttributionUnderInvoice"];
            this.isDefaultInvoiceSetting = _data["isDefaultInvoiceSetting"];
        }
    }

    static fromJS(data: any): InvoiceSettingCreateModel {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceSettingCreateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyId"] = this.companyId;
        data["invoiceDueDateCount"] = this.invoiceDueDateCount;
        data["invoiceColor"] = this.invoiceColor;
        data["invoiceFooter"] = this.invoiceFooter;
        data["invoiceTerms"] = this.invoiceTerms;
        data["isHideInvoiceHeader"] = this.isHideInvoiceHeader;
        data["isShowPreviousDue"] = this.isShowPreviousDue;
        data["isShowInvoiceCreatorName"] = this.isShowInvoiceCreatorName;
        data["isShowCustomerSignature"] = this.isShowCustomerSignature;
        data["isCreateInvoiceWithoutPurchase"] = this.isCreateInvoiceWithoutPurchase;
        data["isServiceProviderAttributionUnderInvoice"] = this.isServiceProviderAttributionUnderInvoice;
        data["isDefaultInvoiceSetting"] = this.isDefaultInvoiceSetting;
        return data;
    }
}

export interface IInvoiceSettingCreateModel {
    companyId: number;
    invoiceDueDateCount: number;
    invoiceColor?: string | undefined;
    invoiceFooter?: string | undefined;
    invoiceTerms?: string | undefined;
    isHideInvoiceHeader?: boolean;
    isShowPreviousDue?: boolean;
    isShowInvoiceCreatorName?: boolean;
    isShowCustomerSignature?: boolean;
    isCreateInvoiceWithoutPurchase?: boolean;
    isServiceProviderAttributionUnderInvoice?: boolean;
    isDefaultInvoiceSetting?: boolean;
}

export class InvoiceSettingUpdateModel implements IInvoiceSettingUpdateModel {
    id?: number;
    companyId!: number;
    invoiceDueDateCount!: number;
    invoiceColor?: string | undefined;
    invoiceFooter?: string | undefined;
    invoiceTerms?: string | undefined;
    isHideInvoiceHeader?: boolean;
    isShowPreviousDue?: boolean;
    isShowInvoiceCreatorName?: boolean;
    isShowCustomerSignature?: boolean;
    isCreateInvoiceWithoutPurchase?: boolean;
    isServiceProviderAttributionUnderInvoice?: boolean;
    isDefaultInvoiceSetting?: boolean;

    constructor(data?: IInvoiceSettingUpdateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyId = _data["companyId"];
            this.invoiceDueDateCount = _data["invoiceDueDateCount"];
            this.invoiceColor = _data["invoiceColor"];
            this.invoiceFooter = _data["invoiceFooter"];
            this.invoiceTerms = _data["invoiceTerms"];
            this.isHideInvoiceHeader = _data["isHideInvoiceHeader"];
            this.isShowPreviousDue = _data["isShowPreviousDue"];
            this.isShowInvoiceCreatorName = _data["isShowInvoiceCreatorName"];
            this.isShowCustomerSignature = _data["isShowCustomerSignature"];
            this.isCreateInvoiceWithoutPurchase = _data["isCreateInvoiceWithoutPurchase"];
            this.isServiceProviderAttributionUnderInvoice = _data["isServiceProviderAttributionUnderInvoice"];
            this.isDefaultInvoiceSetting = _data["isDefaultInvoiceSetting"];
        }
    }

    static fromJS(data: any): InvoiceSettingUpdateModel {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceSettingUpdateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyId"] = this.companyId;
        data["invoiceDueDateCount"] = this.invoiceDueDateCount;
        data["invoiceColor"] = this.invoiceColor;
        data["invoiceFooter"] = this.invoiceFooter;
        data["invoiceTerms"] = this.invoiceTerms;
        data["isHideInvoiceHeader"] = this.isHideInvoiceHeader;
        data["isShowPreviousDue"] = this.isShowPreviousDue;
        data["isShowInvoiceCreatorName"] = this.isShowInvoiceCreatorName;
        data["isShowCustomerSignature"] = this.isShowCustomerSignature;
        data["isCreateInvoiceWithoutPurchase"] = this.isCreateInvoiceWithoutPurchase;
        data["isServiceProviderAttributionUnderInvoice"] = this.isServiceProviderAttributionUnderInvoice;
        data["isDefaultInvoiceSetting"] = this.isDefaultInvoiceSetting;
        return data;
    }
}

export interface IInvoiceSettingUpdateModel {
    id?: number;
    companyId: number;
    invoiceDueDateCount: number;
    invoiceColor?: string | undefined;
    invoiceFooter?: string | undefined;
    invoiceTerms?: string | undefined;
    isHideInvoiceHeader?: boolean;
    isShowPreviousDue?: boolean;
    isShowInvoiceCreatorName?: boolean;
    isShowCustomerSignature?: boolean;
    isCreateInvoiceWithoutPurchase?: boolean;
    isServiceProviderAttributionUnderInvoice?: boolean;
    isDefaultInvoiceSetting?: boolean;
}

export class CreateInvoiceSettingCommand extends InvoiceSettingCreateModel implements ICreateInvoiceSettingCommand {

    constructor(data?: ICreateInvoiceSettingCommand) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): CreateInvoiceSettingCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInvoiceSettingCommand();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICreateInvoiceSettingCommand extends IInvoiceSettingCreateModel {
}

export class UpdateInvoiceSettingCommand extends InvoiceSettingUpdateModel implements IUpdateInvoiceSettingCommand {

    constructor(data?: IUpdateInvoiceSettingCommand) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): UpdateInvoiceSettingCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateInvoiceSettingCommand();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateInvoiceSettingCommand extends IInvoiceSettingUpdateModel {
}

export class FilterPageResultModelOfModuleGridModel implements IFilterPageResultModelOfModuleGridModel {
    items?: ModuleGridModel[];
    totalCount?: number;

    constructor(data?: IFilterPageResultModelOfModuleGridModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ModuleGridModel.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): FilterPageResultModelOfModuleGridModel {
        data = typeof data === 'object' ? data : {};
        let result = new FilterPageResultModelOfModuleGridModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IFilterPageResultModelOfModuleGridModel {
    items?: ModuleGridModel[];
    totalCount?: number;
}

export class ModuleGridModel implements IModuleGridModel {
    id?: string;
    name?: string;

    constructor(data?: IModuleGridModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ModuleGridModel {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleGridModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IModuleGridModel {
    id?: string;
    name?: string;
}

export class GetModulesByFilterQuery extends FilterPageModel implements IGetModulesByFilterQuery {

    constructor(data?: IGetModulesByFilterQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): GetModulesByFilterQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetModulesByFilterQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IGetModulesByFilterQuery extends IFilterPageModel {
}

export class ModuleViewModel implements IModuleViewModel {
    createModel?: ModuleCreateModel;
    updateModel?: ModuleUpdateModel;
    gridModel?: ModuleGridModel;

    constructor(data?: IModuleViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createModel = _data["createModel"] ? ModuleCreateModel.fromJS(_data["createModel"]) : undefined as any;
            this.updateModel = _data["updateModel"] ? ModuleUpdateModel.fromJS(_data["updateModel"]) : undefined as any;
            this.gridModel = _data["gridModel"] ? ModuleGridModel.fromJS(_data["gridModel"]) : undefined as any;
        }
    }

    static fromJS(data: any): ModuleViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createModel"] = this.createModel ? this.createModel.toJSON() : undefined as any;
        data["updateModel"] = this.updateModel ? this.updateModel.toJSON() : undefined as any;
        data["gridModel"] = this.gridModel ? this.gridModel.toJSON() : undefined as any;
        return data;
    }
}

export interface IModuleViewModel {
    createModel?: ModuleCreateModel;
    updateModel?: ModuleUpdateModel;
    gridModel?: ModuleGridModel;
}

export class ModuleCreateModel implements IModuleCreateModel {
    name!: string;

    constructor(data?: IModuleCreateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ModuleCreateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleCreateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface IModuleCreateModel {
    name: string;
}

export class ModuleUpdateModel implements IModuleUpdateModel {
    id?: number;
    name!: string;

    constructor(data?: IModuleUpdateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ModuleUpdateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleUpdateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IModuleUpdateModel {
    id?: number;
    name: string;
}

export class CreateModuleCommand extends ModuleCreateModel implements ICreateModuleCommand {

    constructor(data?: ICreateModuleCommand) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): CreateModuleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateModuleCommand();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICreateModuleCommand extends IModuleCreateModel {
}

export class UpdateModuleCommand extends ModuleUpdateModel implements IUpdateModuleCommand {

    constructor(data?: IUpdateModuleCommand) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): UpdateModuleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateModuleCommand();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateModuleCommand extends IModuleUpdateModel {
}

export class FilterPageResultModelOfActionGridModel implements IFilterPageResultModelOfActionGridModel {
    items?: ActionGridModel[];
    totalCount?: number;

    constructor(data?: IFilterPageResultModelOfActionGridModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ActionGridModel.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): FilterPageResultModelOfActionGridModel {
        data = typeof data === 'object' ? data : {};
        let result = new FilterPageResultModelOfActionGridModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IFilterPageResultModelOfActionGridModel {
    items?: ActionGridModel[];
    totalCount?: number;
}

export class ActionGridModel implements IActionGridModel {
    id?: string;
    name?: string;

    constructor(data?: IActionGridModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ActionGridModel {
        data = typeof data === 'object' ? data : {};
        let result = new ActionGridModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IActionGridModel {
    id?: string;
    name?: string;
}

export class GetActionsByFilterQuery extends FilterPageModel implements IGetActionsByFilterQuery {

    constructor(data?: IGetActionsByFilterQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): GetActionsByFilterQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetActionsByFilterQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IGetActionsByFilterQuery extends IFilterPageModel {
}

export class ActionViewModel implements IActionViewModel {
    createModel?: ActionCreateModel;
    updateModel?: ActionUpdateModel;
    gridModel?: ActionGridModel;

    constructor(data?: IActionViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createModel = _data["createModel"] ? ActionCreateModel.fromJS(_data["createModel"]) : undefined as any;
            this.updateModel = _data["updateModel"] ? ActionUpdateModel.fromJS(_data["updateModel"]) : undefined as any;
            this.gridModel = _data["gridModel"] ? ActionGridModel.fromJS(_data["gridModel"]) : undefined as any;
        }
    }

    static fromJS(data: any): ActionViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ActionViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createModel"] = this.createModel ? this.createModel.toJSON() : undefined as any;
        data["updateModel"] = this.updateModel ? this.updateModel.toJSON() : undefined as any;
        data["gridModel"] = this.gridModel ? this.gridModel.toJSON() : undefined as any;
        return data;
    }
}

export interface IActionViewModel {
    createModel?: ActionCreateModel;
    updateModel?: ActionUpdateModel;
    gridModel?: ActionGridModel;
}

export class ActionCreateModel implements IActionCreateModel {
    name!: string;

    constructor(data?: IActionCreateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ActionCreateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ActionCreateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface IActionCreateModel {
    name: string;
}

export class ActionUpdateModel implements IActionUpdateModel {
    id?: number;
    name!: string;

    constructor(data?: IActionUpdateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ActionUpdateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ActionUpdateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IActionUpdateModel {
    id?: number;
    name: string;
}

export class CreateActionCommand extends ActionCreateModel implements ICreateActionCommand {

    constructor(data?: ICreateActionCommand) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): CreateActionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateActionCommand();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICreateActionCommand extends IActionCreateModel {
}

export class UpdateActionCommand extends ActionUpdateModel implements IUpdateActionCommand {

    constructor(data?: IUpdateActionCommand) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): UpdateActionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateActionCommand();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateActionCommand extends IActionUpdateModel {
}

export class FilterPageResultModelOfCityGridModel implements IFilterPageResultModelOfCityGridModel {
    items?: CityGridModel[];
    totalCount?: number;

    constructor(data?: IFilterPageResultModelOfCityGridModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CityGridModel.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): FilterPageResultModelOfCityGridModel {
        data = typeof data === 'object' ? data : {};
        let result = new FilterPageResultModelOfCityGridModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IFilterPageResultModelOfCityGridModel {
    items?: CityGridModel[];
    totalCount?: number;
}

export class CityGridModel implements ICityGridModel {
    id?: string;
    name?: string;
    countryName?: string;

    constructor(data?: ICityGridModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.countryName = _data["countryName"];
        }
    }

    static fromJS(data: any): CityGridModel {
        data = typeof data === 'object' ? data : {};
        let result = new CityGridModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["countryName"] = this.countryName;
        return data;
    }
}

export interface ICityGridModel {
    id?: string;
    name?: string;
    countryName?: string;
}

export class GetCityByFilterQuery extends FilterPageModel implements IGetCityByFilterQuery {

    constructor(data?: IGetCityByFilterQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): GetCityByFilterQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetCityByFilterQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IGetCityByFilterQuery extends IFilterPageModel {
}

export class CityCreateModel implements ICityCreateModel {
    name!: string;
    countryId!: number;

    constructor(data?: ICityCreateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.countryId = _data["countryId"];
        }
    }

    static fromJS(data: any): CityCreateModel {
        data = typeof data === 'object' ? data : {};
        let result = new CityCreateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["countryId"] = this.countryId;
        return data;
    }
}

export interface ICityCreateModel {
    name: string;
    countryId: number;
}

export class CreateCityCommand extends CityCreateModel implements ICreateCityCommand {

    constructor(data?: ICreateCityCommand) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): CreateCityCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCityCommand();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICreateCityCommand extends ICityCreateModel {
}

export class CityViewModel implements ICityViewModel {
    createModel?: CityCreateModel;
    updateModel?: CityUpdateModel;
    gridModel?: CityGridModel;
    optionsDataSources?: any;

    constructor(data?: ICityViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createModel = _data["createModel"] ? CityCreateModel.fromJS(_data["createModel"]) : undefined as any;
            this.updateModel = _data["updateModel"] ? CityUpdateModel.fromJS(_data["updateModel"]) : undefined as any;
            this.gridModel = _data["gridModel"] ? CityGridModel.fromJS(_data["gridModel"]) : undefined as any;
            this.optionsDataSources = _data["optionsDataSources"];
        }
    }

    static fromJS(data: any): CityViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new CityViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createModel"] = this.createModel ? this.createModel.toJSON() : undefined as any;
        data["updateModel"] = this.updateModel ? this.updateModel.toJSON() : undefined as any;
        data["gridModel"] = this.gridModel ? this.gridModel.toJSON() : undefined as any;
        data["optionsDataSources"] = this.optionsDataSources;
        return data;
    }
}

export interface ICityViewModel {
    createModel?: CityCreateModel;
    updateModel?: CityUpdateModel;
    gridModel?: CityGridModel;
    optionsDataSources?: any;
}

export class CityUpdateModel implements ICityUpdateModel {
    id?: number;
    tempId?: string | undefined;
    name!: string;
    countryId?: number | undefined;

    constructor(data?: ICityUpdateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tempId = _data["tempId"];
            this.name = _data["name"];
            this.countryId = _data["countryId"];
        }
    }

    static fromJS(data: any): CityUpdateModel {
        data = typeof data === 'object' ? data : {};
        let result = new CityUpdateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tempId"] = this.tempId;
        data["name"] = this.name;
        data["countryId"] = this.countryId;
        return data;
    }
}

export interface ICityUpdateModel {
    id?: number;
    tempId?: string | undefined;
    name: string;
    countryId?: number | undefined;
}

export class UpdateCityCommand extends CityUpdateModel implements IUpdateCityCommand {

    constructor(data?: IUpdateCityCommand) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): UpdateCityCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCityCommand();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateCityCommand extends ICityUpdateModel {
}

export class SelectModel implements ISelectModel {
    id?: any;
    name?: string;
    group?: string;
    isDefault?: boolean;
    valueOne?: any;
    valueTwo?: any;
    valueThree?: any;
    valueFour?: any;
    displayOrder?: number;

    constructor(data?: ISelectModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.group = _data["group"];
            this.isDefault = _data["isDefault"];
            this.valueOne = _data["valueOne"];
            this.valueTwo = _data["valueTwo"];
            this.valueThree = _data["valueThree"];
            this.valueFour = _data["valueFour"];
            this.displayOrder = _data["displayOrder"];
        }
    }

    static fromJS(data: any): SelectModel {
        data = typeof data === 'object' ? data : {};
        let result = new SelectModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["group"] = this.group;
        data["isDefault"] = this.isDefault;
        data["valueOne"] = this.valueOne;
        data["valueTwo"] = this.valueTwo;
        data["valueThree"] = this.valueThree;
        data["valueFour"] = this.valueFour;
        data["displayOrder"] = this.displayOrder;
        return data;
    }
}

export interface ISelectModel {
    id?: any;
    name?: string;
    group?: string;
    isDefault?: boolean;
    valueOne?: any;
    valueTwo?: any;
    valueThree?: any;
    valueFour?: any;
    displayOrder?: number;
}

export class CountryGridModel implements ICountryGridModel {
    id?: string;
    name?: string;
    code?: string;
    icon?: string | undefined;
    cities?: CityGridModel[];

    constructor(data?: ICountryGridModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.icon = _data["icon"];
            if (Array.isArray(_data["cities"])) {
                this.cities = [] as any;
                for (let item of _data["cities"])
                    this.cities!.push(CityGridModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CountryGridModel {
        data = typeof data === 'object' ? data : {};
        let result = new CountryGridModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["icon"] = this.icon;
        if (Array.isArray(this.cities)) {
            data["cities"] = [];
            for (let item of this.cities)
                data["cities"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ICountryGridModel {
    id?: string;
    name?: string;
    code?: string;
    icon?: string | undefined;
    cities?: CityGridModel[];
}

export class FilterPageResultModelOfCountryGridModel implements IFilterPageResultModelOfCountryGridModel {
    items?: CountryGridModel[];
    totalCount?: number;

    constructor(data?: IFilterPageResultModelOfCountryGridModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CountryGridModel.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): FilterPageResultModelOfCountryGridModel {
        data = typeof data === 'object' ? data : {};
        let result = new FilterPageResultModelOfCountryGridModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IFilterPageResultModelOfCountryGridModel {
    items?: CountryGridModel[];
    totalCount?: number;
}

export class GetCountriesByFilterQuery extends FilterPageModel implements IGetCountriesByFilterQuery {

    constructor(data?: IGetCountriesByFilterQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): GetCountriesByFilterQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetCountriesByFilterQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IGetCountriesByFilterQuery extends IFilterPageModel {
}

export class CountryViewModel implements ICountryViewModel {
    createModel?: CountryCreateModel;
    updateModel?: CountryUpdateModel;
    gridModel?: CountryGridModel;

    constructor(data?: ICountryViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createModel = _data["createModel"] ? CountryCreateModel.fromJS(_data["createModel"]) : undefined as any;
            this.updateModel = _data["updateModel"] ? CountryUpdateModel.fromJS(_data["updateModel"]) : undefined as any;
            this.gridModel = _data["gridModel"] ? CountryGridModel.fromJS(_data["gridModel"]) : undefined as any;
        }
    }

    static fromJS(data: any): CountryViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new CountryViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createModel"] = this.createModel ? this.createModel.toJSON() : undefined as any;
        data["updateModel"] = this.updateModel ? this.updateModel.toJSON() : undefined as any;
        data["gridModel"] = this.gridModel ? this.gridModel.toJSON() : undefined as any;
        return data;
    }
}

export interface ICountryViewModel {
    createModel?: CountryCreateModel;
    updateModel?: CountryUpdateModel;
    gridModel?: CountryGridModel;
}

export class CountryCreateModel implements ICountryCreateModel {
    name!: string;
    code!: string;
    icon?: string | undefined;
    cities?: CityCreateModel[] | undefined;

    constructor(data?: ICountryCreateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.icon = _data["icon"];
            if (Array.isArray(_data["cities"])) {
                this.cities = [] as any;
                for (let item of _data["cities"])
                    this.cities!.push(CityCreateModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CountryCreateModel {
        data = typeof data === 'object' ? data : {};
        let result = new CountryCreateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["icon"] = this.icon;
        if (Array.isArray(this.cities)) {
            data["cities"] = [];
            for (let item of this.cities)
                data["cities"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ICountryCreateModel {
    name: string;
    code: string;
    icon?: string | undefined;
    cities?: CityCreateModel[] | undefined;
}

export class CountryUpdateModel implements ICountryUpdateModel {
    id?: number;
    name!: string;
    code!: string;
    icon?: string | undefined;
    cities?: CityUpdateModel[];

    constructor(data?: ICountryUpdateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.icon = _data["icon"];
            if (Array.isArray(_data["cities"])) {
                this.cities = [] as any;
                for (let item of _data["cities"])
                    this.cities!.push(CityUpdateModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CountryUpdateModel {
        data = typeof data === 'object' ? data : {};
        let result = new CountryUpdateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["icon"] = this.icon;
        if (Array.isArray(this.cities)) {
            data["cities"] = [];
            for (let item of this.cities)
                data["cities"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ICountryUpdateModel {
    id?: number;
    name: string;
    code: string;
    icon?: string | undefined;
    cities?: CityUpdateModel[];
}

export class CreateCountryCommand extends CountryCreateModel implements ICreateCountryCommand {

    constructor(data?: ICreateCountryCommand) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): CreateCountryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCountryCommand();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICreateCountryCommand extends ICountryCreateModel {
}

export class UpdateCountryCommand extends CountryUpdateModel implements IUpdateCountryCommand {

    constructor(data?: IUpdateCountryCommand) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): UpdateCountryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCountryCommand();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateCountryCommand extends ICountryUpdateModel {
}

export class UserModel implements IUserModel {
    id?: string;
    fullName?: string;
    roleName?: string;
    email?: string;
    token?: string;
    employeeId?: number | undefined;
    image?: string | undefined;

    constructor(data?: IUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fullName = _data["fullName"];
            this.roleName = _data["roleName"];
            this.email = _data["email"];
            this.token = _data["token"];
            this.employeeId = _data["employeeId"];
            this.image = _data["image"];
        }
    }

    static fromJS(data: any): UserModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["roleName"] = this.roleName;
        data["email"] = this.email;
        data["token"] = this.token;
        data["employeeId"] = this.employeeId;
        data["image"] = this.image;
        return data;
    }
}

export interface IUserModel {
    id?: string;
    fullName?: string;
    roleName?: string;
    email?: string;
    token?: string;
    employeeId?: number | undefined;
    image?: string | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class RegisterModel implements IRegisterModel {
    fullName!: string;
    phone!: string;
    email!: string;
    password!: string;
    confirmPassword!: string;

    constructor(data?: IRegisterModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullName = _data["fullName"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): RegisterModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        return data;
    }
}

export interface IRegisterModel {
    fullName: string;
    phone: string;
    email: string;
    password: string;
    confirmPassword: string;
}

export class RegistrationCommand extends RegisterModel implements IRegistrationCommand {

    constructor(data?: IRegistrationCommand) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): RegistrationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RegistrationCommand();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IRegistrationCommand extends IRegisterModel {
}

export class AuthenticationViewModel implements IAuthenticationViewModel {
    userModel?: UserModel;
    registerModel?: RegisterModel;
    loginModel?: LoginModel;

    constructor(data?: IAuthenticationViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userModel = _data["userModel"] ? UserModel.fromJS(_data["userModel"]) : undefined as any;
            this.registerModel = _data["registerModel"] ? RegisterModel.fromJS(_data["registerModel"]) : undefined as any;
            this.loginModel = _data["loginModel"] ? LoginModel.fromJS(_data["loginModel"]) : undefined as any;
        }
    }

    static fromJS(data: any): AuthenticationViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userModel"] = this.userModel ? this.userModel.toJSON() : undefined as any;
        data["registerModel"] = this.registerModel ? this.registerModel.toJSON() : undefined as any;
        data["loginModel"] = this.loginModel ? this.loginModel.toJSON() : undefined as any;
        return data;
    }
}

export interface IAuthenticationViewModel {
    userModel?: UserModel;
    registerModel?: RegisterModel;
    loginModel?: LoginModel;
}

export class LoginModel implements ILoginModel {
    email!: string;
    password!: string;

    constructor(data?: ILoginModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginModel {
    email: string;
    password: string;
}

export class LoginCommand extends LoginModel implements ILoginCommand {

    constructor(data?: ILoginCommand) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): LoginCommand {
        data = typeof data === 'object' ? data : {};
        let result = new LoginCommand();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ILoginCommand extends ILoginModel {
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}